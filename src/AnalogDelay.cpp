/*
 * Company: Blackaddr Audio
 * Effect Name: Analog Delay
 * Description: A warm analog-based delay with multiple filters for different flavours. Boss DM3 inspired.
 *
 * This file was auto-generated by Aviate Audio Effect Creator for the Multiverse.
 */
#include <cmath> // used for std::round
#include "AnalogDelay.h"
#include "AnalogDelayFilters.h"

using namespace baCore;

namespace BlackaddrAudio_AnalogDelay {

AnalogDelay::AnalogDelay(float maxDelayMs)
: AudioStream(1, m_inputQueueArray)
{
    m_memory = new AudioDelay(maxDelayMs);
    m_maxDelaySamples = calcAudioSamples(maxDelayMs);
    m_constructFilter();
}

//AnalogDelay::AnalogDelay(size_t numSamples)
//: AudioStream(1, m_inputQueueArray)
//{
//    m_memory = new AudioDelay(numSamples);
//    m_maxDelaySamples = numSamples;
//    m_constructFilter();
//}
//
//// requires preallocated memory large enough
//AnalogDelay::AnalogDelay(ExtMemSlot *slot)
//: AudioStream(1, m_inputQueueArray)
//{
//    m_memory = new AudioDelay(slot);
//    // max delay for external memory is slot size minus one audio block
//    m_maxDelaySamples = (slot->size() / sizeof(int16_t)) - AUDIO_BLOCK_SAMPLES;
//    m_externalMemory = true;
//    m_constructFilter();
//}

AnalogDelay::~AnalogDelay()
{
    if (m_memory) delete m_memory;
    if (m_iir) delete m_iir;
}

// This function just sets up the default filter and coefficients
void AnalogDelay::m_constructFilter(void)
{
    // Use DM3 coefficients by default
    m_iir = new IirBiQuadFilterHQ(DM3_NUM_STAGES, reinterpret_cast<const int32_t *>(&DM3), DM3_COEFF_SHIFT);
}

void AnalogDelay::setFilterCoeffs(int numStages, const int32_t *coeffs, int coeffShift)
{
    m_iir->changeFilterCoeffs(numStages, coeffs, coeffShift);
}

void AnalogDelay::setFilter(Filter filter)
{
    DEBUG_PRINT(Serial.printf("AnalogDelay::setFilter(): filter set to %d\n\r", (int)filter));
    switch(filter) {
    case Filter::WARM :
        m_iir->changeFilterCoeffs(WARM_NUM_STAGES, reinterpret_cast<const int32_t *>(&WARM), WARM_COEFF_SHIFT);
        break;
    case Filter::DARK :
        m_iir->changeFilterCoeffs(DARK_NUM_STAGES, reinterpret_cast<const int32_t *>(&DARK), DARK_COEFF_SHIFT);
        break;
    case Filter::DM3 :
    default:
        m_iir->changeFilterCoeffs(DM3_NUM_STAGES, reinterpret_cast<const int32_t *>(&DM3), DM3_COEFF_SHIFT);
        break;
    }
}

void AnalogDelay::update(void)
{
    audio_block_t *inputAudioBlock = receiveReadOnly(); // get the next block of input samples

    inputAudioBlock = m_basicInputCheck(inputAudioBlock, 0); // check for disable mode, bypass, or invalid inputs.
    if (!inputAudioBlock) { return; }

    // Update the peak value
    m_updateInputPeak(inputAudioBlock);

    // Otherwise perform normal processing
    // In order to make use of the SPI DMA, we need to request the read from memory first,
    // then do other processing while it fills in the back.
    audio_block_t *blockToOutput = nullptr; // this will hold the output audio
    blockToOutput = allocate();
    if (!blockToOutput) {
        transmit(inputAudioBlock);
        release(inputAudioBlock);
        return; // skip this update cycle due to failure
    }

    // get the data. If using external memory with DMA, this won't be filled until
    // later.
    m_memory->getSamples(blockToOutput, m_delaySamples);

    // If using DMA, we need something else to do while that read executes, so
    // move on to input preprocessing

    // Preprocessing
    audio_block_t *preProcessed = allocate();
    // mix the input with the feedback path in the pre-processing stage
    m_preProcessing(preProcessed, inputAudioBlock, m_previousBlock);

    // consider doing the BBD post processing here to use up more time while waiting
    // for the read data to come back
    audio_block_t *blockToRelease = m_memory->addBlock(preProcessed);


    // BACK TO OUTPUT PROCESSING
    // Check if external DMA, if so, we need to be sure the read is completed
    if (m_externalMemory && m_memory->getSlot()->isUseDma()) {
        // Using DMA
        while (m_memory->getSlot()->isReadBusy()) {}
    }

    // perform the wet/dry mix mix
    m_postProcessing(blockToOutput, inputAudioBlock, blockToOutput);
    m_updateOutputPeak(blockToOutput);
    transmit(blockToOutput);

    release(inputAudioBlock);
    if (m_previousBlock) { release(m_previousBlock); }
    m_previousBlock = blockToOutput;

    if (m_blockToRelease) { release(m_blockToRelease); }
    m_blockToRelease = blockToRelease;
}

void AnalogDelay::m_preProcessing(audio_block_t *out, audio_block_t *dry, audio_block_t *wet)
{
    if ( out && dry && wet) {
        alphaBlend(out, dry, wet, m_feedback);
        m_iir->process(out->data, out->data, AUDIO_BLOCK_SAMPLES);
    } else if (dry) {
        memcpy(out->data, dry->data, sizeof(int16_t) * AUDIO_BLOCK_SAMPLES);
    }
}

void AnalogDelay::m_postProcessing(audio_block_t *out, audio_block_t *dry, audio_block_t *wet)
{
    if (!out) return; // no valid output buffer

    if ( out && dry && wet) {
        // Simulate the LPF IIR nature of the analog systems
        //m_iir->process(wet->data, wet->data, AUDIO_BLOCK_SAMPLES);
        alphaBlend(out, dry, wet, m_mix);
    } else if (dry) {
        memcpy(out->data, dry->data, sizeof(int16_t) * AUDIO_BLOCK_SAMPLES);
    }
    // Set the output volume
    gainAdjust(out, out, m_volume/4.0f, 2);

}

void AnalogDelay::delayMs(float milliseconds)
{
    size_t delaySamples = calcAudioSamples(milliseconds);

    if (!m_memory) { Serial.println("delay(): m_memory is not valid"); return; }

    if (!m_externalMemory) {
        // internal memory
        m_maxDelaySamples = m_memory->getMaxDelaySamples();
        //QueuePosition queuePosition = calcQueuePosition(milliseconds);
        //Serial.println(String("CONFIG: delay:") + delaySamples + String(" queue position ") + queuePosition.index + String(":") + queuePosition.offset);
    } else {
        // external memory
        ExtMemSlot *slot = m_memory->getSlot();
        m_maxDelaySamples = (slot->size() / sizeof(int16_t))-AUDIO_BLOCK_SAMPLES;

        if (!slot) { Serial.println("ERROR: slot ptr is not valid"); }
        if (!slot->isEnabled()) {
            slot->enable();
            Serial.println("WEIRD: slot was not enabled");
        }
    }

    if (delaySamples > m_maxDelaySamples) {
        // this exceeds max delay value, limit it.
        delaySamples = m_maxDelaySamples;
    }
    m_delaySamples = delaySamples;
}

void AnalogDelay::delaySamples(size_t numDelaySamples)
{
    if (!m_memory) { Serial.println("delay(): m_memory is not valid"); }

    if (!m_externalMemory) {
        // internal memory
        m_maxDelaySamples = m_memory->getMaxDelaySamples();
        //QueuePosition queuePosition = calcQueuePosition(delaySamples);
        //Serial.println(String("CONFIG: delay:") + delaySamples + String(" queue position ") + queuePosition.index + String(":") + queuePosition.offset);
    } else {
        // external memory
        //Serial.println(String("CONFIG: delay:") + delaySamples);
        ExtMemSlot *slot = m_memory->getSlot();
        m_maxDelaySamples = (slot->size() / sizeof(int16_t))-AUDIO_BLOCK_SAMPLES;
        if (!slot->isEnabled()) {
            slot->enable();
        }
    }

    if (numDelaySamples > m_maxDelaySamples) {
        // this exceeds max delay value, limit it.
        numDelaySamples = m_maxDelaySamples;
    }

    DEBUG_PRINT(Serial.printf("AnalogDelay::delaySamples(): delay samples set to %d\n\r", m_delaySamples));
    m_delaySamples = numDelaySamples;
}

void AnalogDelay::delayFractionMax(float delayFraction)
{
    size_t delaySamples = static_cast<size_t>(static_cast<float>(m_memory->getMaxDelaySamples()) * delayFraction);

    if (!m_memory) { Serial.println("delay(): m_memory is not valid"); }

    if (!m_externalMemory) {
        // internal memory
        m_maxDelaySamples = m_memory->getMaxDelaySamples();
        QueuePosition queuePosition = calcQueuePosition(delaySamples);
        Serial.println(String("CONFIG: delay:") + delaySamples + String(" queue position ") + queuePosition.index + String(":") + queuePosition.offset);
    } else {
        // external memory
        //Serial.println(String("CONFIG: delay:") + delaySamples);
        ExtMemSlot *slot = m_memory->getSlot();
        m_maxDelaySamples = (slot->size() / sizeof(int16_t))-AUDIO_BLOCK_SAMPLES;
        if (!slot->isEnabled()) {
            slot->enable();
        }
    }

    if (delaySamples > m_maxDelaySamples) {
        // this exceeds max delay value, limit it.
        delaySamples = m_maxDelaySamples;
    }
    m_delaySamples = delaySamples;
    DEBUG_PRINT(Serial.printf("AnalogDelay::delayFractionMax(): delay samples set to %d\n\r", m_delaySamples));
}


void AnalogDelay::filter(float value)
{
    // perform any necessary conversion to user variables, validation, etc.
    DEBUG_PRINT(Serial.printf("AnalogDelay::filter(): value is %f\n\r", value));
    m_filter = std::roundf(value * static_cast<float>(static_cast<unsigned>(Filter::NUM_FILTERS)-1));
    setFilter(static_cast<Filter>(m_filter));
}

void AnalogDelay::delay(float value)
{
    // perform any necessary conversion to user variables, validation, etc.
    m_delay = value;
    delayFractionMax(m_delay);
}

void AnalogDelay::mix(float value)
{
    // perform any necessary conversion to user variables, validation, etc.
    m_mix = value;
}

void AnalogDelay::feedback(float value)
{
    // perform any necessary conversion to user variables, validation, etc.
    m_feedback = value;
}

void AnalogDelay::volume(float value)
{
    // perform any necessary conversion to user variables, validation, etc.
    //m_volume = value;
    volumeDb(-40.0f + (value * 50.0f)); // 50db dynamic range
}


}
